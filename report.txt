TRACKER APPLICATION - TECHNICAL REPORT

Project: Fitness Tracker Web Application
Student ID: 33801956
Technology Stack: Node.js, Express.js, MySQL, EJS Templates
Deployment URL: http://www.doc.gold.ac.uk/usr/112/
TABLE OF CONTENTS
1.	Project Overview
2.	System Architecture
3.	Database Design
4.	Application Structure
5.	Core Features & Implementation
6.	Authentication System
7.	Workout Management
8.	Goals Management
9.	Search Functionality
10.	Security Considerations
11.	Deployment Configuration
12.	Testing & Default Credentials
1. PROJECT OVERVIEW

FitTracker is a full-stack web application designed to help users track their fitness journey. The application allows users to:
•	Register and manage their accounts
•	Log and track workouts with exercises
•	Set and monitor fitness goals
•	Browse an exercise library
•	Search across workouts and exercises
•	View personal statistics and progress

The application follows the MVC (Model-View-Controller) architecture pattern and uses server-side rendering with EJS templates.
2. SYSTEM ARCHITECTURE

Technology Stack:
Component	Version / Description
Runtime	Node.js
Framework	Express.js v4.18.2
Database	MySQL 5.7
Template Engine	EJS v3.1.9
Authentication	bcrypt v5.1.1 for password hashing
Session Management	express-session v1.17.3
Environment Config	dotenv v16.3.1
Architecture Diagram:
[Browser] <---> [Express Server] <---> [MySQL Database]
                      |
                [EJS Templates]
                      |
                [Static Files]
Application Entry Point (index.js):
// Fitness Tracker Application - Main entry point
require("dotenv").config();
const express = require("express");
const session = require("express-session");
const path = require("path");

const app = express();
const PORT = 8000;

// Import database and routes
const { testConnection } = require("./config/database");
const mainRoutes = require("./routes/main");
const authRoutes = require("./routes/auth");
const workoutRoutes = require("./routes/workouts");
const goalRoutes = require("./routes/goals");
const apiRoutes = require("./routes/api");

// Middleware
app.use(express.urlencoded({ extended: true }));
app.use(express.json());
app.use(express.static(path.join(__dirname, "public")));

// Session configuration
app.use(
  session({
    secret: process.env.SESSION_SECRET || "fitness-tracker-secret",
    resave: false,
    saveUninitialized: false,
    cookie: {
      secure: false,
      maxAge: 24 * 60 * 60 * 1000, // 24 hours
    },
  })
);

// Make session data and base path available to all views
app.use((req, res, next) => {
  res.locals.user = req.session.user || null;
  res.locals.success = req.session.success;
  res.locals.error = req.session.error;
  res.locals.basePath = process.env.BASE_PATH || "";
  delete req.session.success;
  delete req.session.error;
  next();
});

// View engine setup
app.set("view engine", "ejs");
app.set("views", path.join(__dirname, "views"));

// Routes
app.use("/", mainRoutes);
app.use("/auth", authRoutes);
app.use("/workouts", workoutRoutes);
app.use("/goals", goalRoutes);
app.use("/api", apiRoutes);

// Start server with database connection test
app.listen(PORT, async () => {
  console.log(`Fitness Tracker app listening on port ${PORT}`);
  const dbConnected = await testConnection();
  if (!dbConnected) {
    console.error("WARNING: Database connection failed.");
  }
});
3. DATABASE DESIGN

Database Schema Diagram:
users (1) ----< (N) workouts ----< (N) workout_exercises
  |                                          |
  |                                          |
  +----< (N) goals                    exercises (N) >----+
  |                                          |
  +----< (1) user_profiles          exercise_categories
Tables Overview:
1.	USERS TABLE
CREATE TABLE users (
    id INT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) NOT NULL UNIQUE,
    email VARCHAR(100) NOT NULL UNIQUE,
    password_hash VARCHAR(255) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);
2.	USER_PROFILES TABLE
CREATE TABLE user_profiles (
    id INT AUTO_INCREMENT PRIMARY KEY,
    user_id INT NOT NULL UNIQUE,
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    date_of_birth DATE,
    gender ENUM('male', 'female', 'other', 'prefer_not_to_say'),
    height_cm DECIMAL(5,2),
    weight_kg DECIMAL(5,2),
    activity_level ENUM('sedentary', 'light', 'moderate', 'active', 'very_active'),
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);
3.	EXERCISE_CATEGORIES TABLE
CREATE TABLE exercise_categories (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(50) NOT NULL UNIQUE,
    description TEXT,
    icon VARCHAR(50)
);
4.	EXERCISES TABLE
CREATE TABLE exercises (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    description TEXT,
    category_id INT,
    calories_per_minute DECIMAL(5,2),
    muscle_group VARCHAR(100),
    difficulty ENUM('beginner', 'intermediate', 'advanced') DEFAULT 'beginner',
    FOREIGN KEY (category_id) REFERENCES exercise_categories(id) ON DELETE SET NULL
);
5.	WORKOUTS TABLE
CREATE TABLE workouts (
    id INT AUTO_INCREMENT PRIMARY KEY,
    user_id INT NOT NULL,
    name VARCHAR(100) NOT NULL,
    workout_date DATE NOT NULL,
    duration_minutes INT,
    total_calories INT,
    notes TEXT,
    rating INT CHECK (rating >= 1 AND rating <= 5),
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);
6.	WORKOUT_EXERCISES TABLE
CREATE TABLE workout_exercises (
    id INT AUTO_INCREMENT PRIMARY KEY,
    workout_id INT NOT NULL,
    exercise_id INT NOT NULL,
    sets INT,
    reps INT,
    weight_kg DECIMAL(5,2),
    duration_minutes INT,
    calories_burned INT,
    notes TEXT,
    FOREIGN KEY (workout_id) REFERENCES workouts(id) ON DELETE CASCADE,
    FOREIGN KEY (exercise_id) REFERENCES exercises(id) ON DELETE CASCADE
);
7.	GOALS TABLE
CREATE TABLE goals (
    id INT AUTO_INCREMENT PRIMARY KEY,
    user_id INT NOT NULL,
    title VARCHAR(100) NOT NULL,
    description TEXT,
    goal_type ENUM('weight_loss', 'muscle_gain', 'endurance', 'flexibility', 
                   'general_fitness', 'other') NOT NULL,
    target_value DECIMAL(10,2),
    current_value DECIMAL(10,2) DEFAULT 0,
    unit VARCHAR(20),
    start_date DATE NOT NULL,
    target_date DATE,
    status ENUM('active', 'completed', 'abandoned') DEFAULT 'active',
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);
Database Views:
1.	WORKOUT_SUMMARY
CREATE VIEW workout_summary AS
SELECT 
    w.id, w.user_id, u.username, w.name, w.workout_date,
    w.duration_minutes, w.total_calories, w.rating,
    COUNT(we.id) as exercise_count
FROM workouts w
JOIN users u ON w.user_id = u.id
LEFT JOIN workout_exercises we ON w.id = we.workout_id
GROUP BY w.id;
2.	USER_STATS
CREATE VIEW user_stats AS
SELECT 
    u.id as user_id, u.username,
    COUNT(DISTINCT w.id) as total_workouts,
    COALESCE(SUM(w.duration_minutes), 0) as total_minutes,
    COALESCE(SUM(w.total_calories), 0) as total_calories,
    COALESCE(AVG(w.rating), 0) as avg_rating,
    COUNT(DISTINCT g.id) as total_goals,
    SUM(CASE WHEN g.status = 'completed' THEN 1 ELSE 0 END) as completed_goals
FROM users u
LEFT JOIN workouts w ON u.id = w.user_id
LEFT JOIN goals g ON u.id = g.user_id
GROUP BY u.id, u.username;
Database Connection (config/database.js):
const mysql = require("mysql2/promise");

const pool = mysql.createPool({
  host: process.env.HEALTH_HOST || "localhost",
  user: process.env.HEALTH_USER || "health_app",
  password: process.env.HEALTH_PASSWORD || "qwertyuiop",
  database: process.env.HEALTH_DATABASE || "health",
  waitForConnections: true,
  connectionLimit: 10,
  queueLimit: 0,
});

async function testConnection() {
  try {
    const connection = await pool.getConnection();
    console.log("Database connected successfully");
    connection.release();
    return true;
  } catch (error) {
    console.error("Database connection failed:", error.message);
    return false;
  }
}

module.exports = { pool, testConnection };

4. APPLICATION STRUCTURE

Directory Structure:
10_health_33801956/
├── index.js                 # Application entry point
├── package.json             # Dependencies and scripts
├── .env                     # Environment variables
├── create_db.sql            # Database schema
├── insert_test_data.sql     # Test data
│
├── config/
│   └── database.js          # Database connection pool
│
├── middleware/
│   └── auth.js              # Authentication middleware
│
├── routes/
│   ├── main.js              # Home, About, Search routes
│   ├── auth.js              # Login, Register, Logout routes
│   ├── workouts.js          # Workout CRUD routes
│   ├── goals.js             # Goals CRUD routes
│   └── api.js               # REST API endpoints
│
├── views/
│   ├── partials/
│   │   ├── header.ejs       # Common header with navigation
│   │   └── footer.ejs       # Common footer
│   ├── home.ejs             # Home page
│   ├── about.ejs            # About page
│   ├── search.ejs           # Search results page
│   ├── exercises.ejs        # Exercise library
│   ├── exercise-detail.ejs  # Single exercise view
│   ├── 404.ejs              # Not found page
│   ├── error.ejs            # Error page
│   ├── auth/
│   │   ├── login.ejs        # Login form
│   │   ├── register.ejs     # Registration form
│   │   └── profile.ejs      # User profile
│   ├── workouts/
│   │   ├── list.ejs         # Workout list
│   │   ├── form.ejs         # Create/Edit workout
│   │   └── detail.ejs       # Workout details
│   └── goals/
│       ├── list.ejs         # Goals list
│       ├── form.ejs         # Create/Edit goal
│       └── detail.ejs       # Goal details
│
└── public/
    └── css/
        └── style.css        # Application styles
5. CORE FEATURES & IMPLEMENTATION

Home Page Route (routes/main.js):
router.get("/", async (req, res) => {
  let stats = { totalUsers: 0, totalWorkouts: 0, totalExercises: 0 };
  let recentWorkouts = [];
  let userStats = null;

  try {
    const [userCount] = await pool.query("SELECT COUNT(*) as count FROM users");
    const [workoutCount] = await pool.query("SELECT COUNT(*) as count FROM workouts");
    const [exerciseCount] = await pool.query("SELECT COUNT(*) as count FROM exercises");

    stats.totalUsers = userCount[0].count;
    stats.totalWorkouts = workoutCount[0].count;
    stats.totalExercises = exerciseCount[0].count;
  } catch (dbError) {
    console.log("Database stats error:", dbError.message);
  }

  if (req.session && req.session.user) {
    try {
      const [workouts] = await pool.query(
        `SELECT w.*, COUNT(we.id) as exercise_count 
         FROM workouts w 
         LEFT JOIN workout_exercises we ON w.id = we.workout_id 
         WHERE w.user_id = ? 
         GROUP BY w.id 
         ORDER BY w.workout_date DESC 
         LIMIT 5`,
        [req.session.user.id]
      );
      recentWorkouts = workouts || [];

      const [statsResult] = await pool.query(
        `SELECT * FROM user_stats WHERE user_id = ?`,
        [req.session.user.id]
      );
      userStats = statsResult[0] || null;
    } catch (dbError) {
      console.log("User data error:", dbError.message);
    }
  }

  res.render("home", {
    title: "Fitness Tracker - Home",
    stats: stats,
    recentWorkouts: recentWorkouts,
    userStats: userStats,
  });
});
6. AUTHENTICATION SYSTEM

Middleware (middleware/auth.js):
function isAuthenticated(req, res, next) {
  if (req.session.user) return next();
  req.session.error = "Please log in to access this page";
  res.redirect("/auth/login");
}

function isNotAuthenticated(req, res, next) {
  if (!req.session.user) return next();
  res.redirect("/");
}

function validatePassword(password) {
  const errors = [];
  if (password.length < 8) errors.push("Password must be at least 8 characters long");
  if (!/[a-z]/.test(password)) errors.push("Password must contain at least one lowercase letter");
  if (!/[A-Z]/.test(password)) errors.push("Password must contain at least one uppercase letter");
  if (!/[0-9]/.test(password)) errors.push("Password must contain at least one number");
  if (!/[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]/.test(password)) errors.push("Password must contain at least one special character");
  return { isValid: errors.length === 0, errors: errors };
}

module.exports = { isAuthenticated, isNotAuthenticated, validatePassword };
Login Route (routes/auth.js):
router.post("/login", isNotAuthenticated, async (req, res) => {
  const { username, password } = req.body;
  const errors = [];

  if (!username || !password) {
    errors.push("Please enter both username and password");
    return res.render("auth/login", { title: "Login", errors });
  }

  try {
    const [users] = await pool.query("SELECT * FROM users WHERE username = ?", [username]);
    if (users.length === 0) {
      errors.push("Invalid username or password");
      return res.render("auth/login", { title: "Login", errors });
    }

    const user = users[0];
    const validPassword = await bcrypt.compare(password, user.password_hash);
    if (!validPassword) {
      errors.push("Invalid username or password");
      return res.render("auth/login", { title: "Login", errors });
    }

    const [profiles] = await pool.query("SELECT * FROM user_profiles WHERE user_id = ?", [user.id]);
    req.session.user = { id: user.id, username: user.username, email: user.email, profile: profiles[0] || null };
    req.session.success = "Welcome back, " + user.username + "!";
    res.redirect("../");
  } catch (error) {
    console.error("Login error:", error);
    errors.push("An error occurred. Please try again.");
    res.render("auth/login", { title: "Login", errors });
  }
});
Registration Route (routes/auth.js):
router.post("/register", isNotAuthenticated, async (req, res) => {
  const { username, email, password, confirmPassword, firstName, lastName } = req.body;
  const errors = [];

  if (!username || username.length < 3) errors.push("Username must be at least 3 characters");
  if (!email || !email.includes("@")) errors.push("Please enter a valid email address");
  if (password !== confirmPassword) errors.push("Passwords do not match");

  const passwordValidation = validatePassword(password);
  if (!passwordValidation.isValid) errors.push(...passwordValidation.errors);

  if (errors.length > 0) return res.render("auth/register", { title: "Register", errors, formData: req.body });

  try {
    const [existing] = await pool.query("SELECT id FROM users WHERE username = ? OR email = ?", [username, email]);
    if (existing.length > 0) {
      errors.push("Username or email already in use");
      return res.render("auth/register", { title: "Register", errors, formData: req.body });
    }

    const hashedPassword = await bcrypt.hash(password, 10);
    const [result] = await pool.query("INSERT INTO users (username, email, password_hash) VALUES (?, ?, ?)", [username, email, hashedPassword]);
    const userId = result.insertId;

    await pool.query("INSERT INTO user_profiles (user_id, first_name, last_name) VALUES (?, ?, ?)", [userId, firstName || null, lastName || null]);
    req.session.user = { id: userId, username, email, profile: { first_name: firstName, last_name: lastName } };
    req.session.success = "Account created successfully!";
    res.redirect("../");
  } catch (error) {
    console.error("Registration error:", error);
    errors.push("An error occurred during registration.");
    res.render("auth/register", { title: "Register", errors, formData: req.body });
  }
});
7. WORKOUT MANAGEMENT

Workout List Route:
router.get("/", isAuthenticated, async (req, res) => {
  const page = parseInt(req.query.page) || 1;
  const limit = 10;
  const offset = (page - 1) * limit;

  try {
    const [workouts] = await pool.query(
      `SELECT w.*, COUNT(we.id) as exercise_count 
       FROM workouts w 
       LEFT JOIN workout_exercises we ON w.id = we.workout_id 
       WHERE w.user_id = ? 
       GROUP BY w.id 
       ORDER BY w.workout_date DESC
       LIMIT ? OFFSET ?`,
      [req.session.user.id, limit, offset]
    );

    const [countResult] = await pool.query("SELECT COUNT(*) as total FROM workouts WHERE user_id = ?", [req.session.user.id]);
    const totalPages = Math.ceil(countResult[0].total / limit);

    res.render("workouts/list", { title: "My Workouts", workouts, currentPage: page, totalPages, totalWorkouts: countResult[0].total });
  } catch (error) {
    console.error("Workouts list error:", error);
    res.render("workouts/list", { title: "My Workouts", workouts: [], currentPage: 1, totalPages: 1, totalWorkouts: 0 });
  }
});
Create Workout Route:
router.post("/new", isAuthenticated, async (req, res) => {
  const { name, workoutDate, durationMinutes, totalCalories, notes, rating, exercises } = req.body;
  const errors = [];

  if (!name || name.trim() === "") errors.push("Workout name is required");
  if (!workoutDate) errors.push("Workout date is required");
  if (errors.length > 0) return res.render("workouts/form", { title: "Log Workout", errors, ... });

  try {
    const [result] = await pool.query(
      `INSERT INTO workouts (user_id, name, workout_date, duration_minutes, total_calories, notes, rating)
       VALUES (?, ?, ?, ?, ?, ?, ?)`,
      [req.session.user.id, name, workoutDate, durationMinutes || null, totalCalories || null, notes || null, rating || null]
    );

    const workoutId = result.insertId;

    if (exercises && Array.isArray(exercises)) {
      for (const ex of exercises) {
        if (ex.exerciseId) {
          await pool.query(
            `INSERT INTO workout_exercises 
             (workout_id, exercise_id, sets, reps, weight_kg, duration_minutes, calories_burned, notes)
             VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
            [workoutId, ex.exerciseId, ex.sets || null, ex.reps || null, ex.weight || null, ex.duration || null, ex.calories || null, ex.notes || null]
          );
        }
      }
    }

    req.session.success = "Workout logged successfully!";
    res.redirect("./" + workoutId);
  } catch (error) {
    console.error("Create workout error:", error);
    errors.push("Could not save workout. Please try again.");
    res.render("workouts/form", { title: "Log Workout", errors, ... });
  }
});

Great! Here’s Sections 8–12 formatted for Microsoft Word, keeping headings, code blocks, and lists Word-friendly.
8. GOALS MANAGEMENT

Goals List Route (routes/goals.js):
router.get("/", isAuthenticated, async (req, res) => {
  const status = req.query.status || "";
  let query = `SELECT * FROM goals WHERE user_id = ?`;
  const params = [req.session.user.id];

  if (status) {
    query += " AND status = ?";
    params.push(status);
  }

  query += ' ORDER BY FIELD(status, "active", "completed", "abandoned"), target_date ASC';
  const [goals] = await pool.query(query, params);

  goals.forEach((goal) => {
    goal.progress = goal.target_value && goal.target_value > 0
      ? Math.min(100, Math.round((goal.current_value / goal.target_value) * 100))
      : 0;
  });

  res.render("goals/list", { title: "My Goals", goals, selectedStatus: status });
});
Create Goal Route (routes/goals.js):
router.post("/new", isAuthenticated, async (req, res) => {
  const { title, description, goalType, targetValue, currentValue, unit, startDate, targetDate } = req.body;
  const errors = [];

  if (!title || title.trim() === "") errors.push("Goal title is required");
  if (!goalType) errors.push("Goal type is required");
  if (!startDate) errors.push("Start date is required");
  if (errors.length > 0) return res.render("goals/form", { title: "Create Goal", errors, goal: req.body });

  try {
    const [result] = await pool.query(
      `INSERT INTO goals (user_id, title, description, goal_type, target_value, current_value, unit, start_date, target_date)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [req.session.user.id, title, description || null, goalType, targetValue || null, currentValue || 0, unit || null, startDate, targetDate || null]
    );

    req.session.success = "Goal created successfully!";
    res.redirect("./" + result.insertId);
  } catch (error) {
    console.error("Create goal error:", error);
    errors.push("Could not save goal. Please try again.");
    res.render("goals/form", { title: "Create Goal", errors, goal: req.body });
  }
});
Update Progress Route (routes/goals.js):
router.post("/:id/progress", isAuthenticated, async (req, res) => {
  const { currentValue } = req.body;

  const [goals] = await pool.query("SELECT * FROM goals WHERE id = ? AND user_id = ?", [req.params.id, req.session.user.id]);
  if (goals.length === 0) return res.status(404).render("404", { title: "Goal Not Found" });

  const goal = goals[0];
  let status = goal.status;

  if (goal.target_value && parseFloat(currentValue) >= parseFloat(goal.target_value)) {
    status = "completed";
  }

  await pool.query("UPDATE goals SET current_value = ?, status = ? WHERE id = ? AND user_id = ?", [currentValue, status, req.params.id, req.session.user.id]);
  req.session.success = status === "completed" ? "Congratulations! Goal completed!" : "Progress updated!";

  res.redirect("./" + req.params.id);
});

9. SEARCH FUNCTIONALITY

Search Route (routes/main.js):
router.get("/search", async (req, res) => {
  const query = req.query.q || "";
  const type = req.query.type || "all";
  let results = { exercises: [], workouts: [], users: [] };

  if (query.trim()) {
    const searchTerm = `%${query}%`;

    if (type === "all" || type === "exercises") {
      const [exercises] = await pool.query(
        `SELECT e.*, c.name as category_name 
         FROM exercises e 
         LEFT JOIN exercise_categories c ON e.category_id = c.id 
         WHERE e.name LIKE ? OR e.description LIKE ? OR e.muscle_group LIKE ?
         LIMIT 20`,
        [searchTerm, searchTerm, searchTerm]
      );
      results.exercises = exercises;
    }

    if ((type === "all" || type === "workouts") && req.session.user) {
      const [workouts] = await pool.query(
        `SELECT * FROM workouts 
         WHERE user_id = ? AND (name LIKE ? OR notes LIKE ?)
         ORDER BY workout_date DESC LIMIT 20`,
        [req.session.user.id, searchTerm, searchTerm]
      );
      results.workouts = workouts;
    }
  }

  res.render("search", { title: "Search - Fitness Tracker", query, type, results });
});

10. SECURITY CONSIDERATIONS

1. Password Security
•	Passwords hashed with bcrypt (10 salt rounds)
•	Strong password rules: 8+ chars, mixed case, numbers, symbols
•	No plain-text password storage

2. SQL Injection Prevention
•	All queries parameterized
•	User input never concatenated directly
// SAFE
const [users] = await pool.query("SELECT * FROM users WHERE username = ?", [username]);
3. Session Security
•	Expire after 24 hours
•	Stored server-side
•	Secret configurable via .env

4. Access Control
•	Protected routes use isAuthenticated
•	Users access only own workouts/goals
•	CRUD ownership verified

5. Input Validation
•	Server-side validation for forms
•	Email format check
•	Required field enforcement

11. DEPLOYMENT CONFIGURATION

Environment Variables (.env)
HEALTH_HOST=localhost
HEALTH_USER=health_app
HEALTH_PASSWORD=qwertyuiop
HEALTH_DATABASE=health
SESSION_SECRET=your-secret-key
BASE_PATH=
VM Deployment Steps
1.	SSH into VM
2.	Navigate to project directory
3.	Install dependencies: npm install
4.	Setup MySQL:
sudo mysql
CREATE DATABASE IF NOT EXISTS health;
CREATE USER IF NOT EXISTS 'health_app'@'localhost' IDENTIFIED BY 'qwertyuiop';
GRANT ALL PRIVILEGES ON health.* TO 'health_app'@'localhost';
FLUSH PRIVILEGES;
USE health;
SOURCE create_db.sql;
SOURCE insert_test_data.sql;
exit
5.	Start application: forever start index.js
6.	Access: http://www.doc.gold.ac.uk/usr/112/ 

Reverse Proxy Configuration
•	Uses basePath for links:
<a href="<%= basePath %>/workouts">My Workouts</a>
•	Redirects:
res.redirect("../");          // Parent path
res.redirect("./" + id);      // Sibling path

12. TESTING & DEFAULT CREDENTIALS

Default Test Users
Username	Password	Email
gold	smiths	gold@example.com
testuser	Test123!@#	test@example.com
Running Locally
1.	Clone repository
2.	Run: npm install
3.	Setup MySQL using create_db.sql
4.	Insert test data using insert_test_data.sql
5.	Run: npm start
6.	Visit: http://localhost:8000

Package Dependencies (package.json)
{
  "dependencies": {
    "bcrypt": "^5.1.1",
    "dotenv": "^16.3.1",
    "ejs": "^3.1.9",
    "express": "^4.18.2",
    "express-session": "^1.17.3",
    "express-validator": "^7.0.1",
    "mysql2": "^3.6.5"
  },
  "devDependencies": {
    "nodemon": "^3.0.2"
  }
}

